# python_microservice_public

Пример json-rpc сервиса на python-flask и uwsgi, с возможностью выгружать метрики в prometheus и
регистрацией в consul.
Этот репозиторий нужен как пример кода в резюме. Здесь используется приватная библиотека, её нельзя открыть, поэтому - без нужных доступов эта штука не запустится. 

python 3.12. Можно заставить работать с 3.7, 3.8, 3.9, но надо шаманить с requirements.
Если у проекта есть другие специфичные требования - описать их здесь.

## Установка нативно:

 * только unix/linux системы (тестировал debian-based)
 * скачай код из репо и ``cd`` в директорию
 * сделай ``make`` и следуй подсказкам

make расскажет откуда взять конфиг и предложит сделать ``make install``.

Если все пройдет без ошибок - после установки в virtual env всех зависимостей в корне проекта будет создан shortcut с именем заданным в конфиге.

## Установка в докере:

1) `cd` в директорию с проектом
2) копируем `docker/current_compose.yaml` в корень проекта с именем `compose.yaml`, при необходимости редактируем под себя
3) копируем `docs/config_docker.sample.yaml` из `docs` в корень проекта с именем `config.yaml`, меняем его под себя при необходимости
4) делаем `docker compose up`

## shortcut 
Имя файла - настраивается в конфиге, но можно и руками поменять.
Сам файл можно перемещать в другие директории и использовать оттуда. Там везде прописываются абсолютные пути.
Файл нужно генерировать заново каждый раз при изменении локации (перемещении) сервиса.

Им можно пользоваться примерно так:

``./service start``

Вызвать help можно также, как и в любой другой терминальной проге:

``./service -h`` или ``./service --help``

Исполнять файл можно вот так:

``./service -h`` или вот так: ``. ./service -h``

Оба способа должны быть эквивалентны

Более подробно о каждой команде и всех плюшках service.py можно почитать в файле docs/service_usage.md

## Алёрты

Умеет отсылать алёрты в telegram и slack, см. конфиг для подробностей.

## makefile

Дополнительные сведения о возможных вариантах использования makefile'а можно почерпнуть заглянув в этот самый файл (но надо понимать bashscript). 

## swagger ui

На адресе http://service.address/swagger_ui есть интерфейс закрытый basic-авторизацией.
В конфиге его можно отключить.

Юзеры для basic авторизации заданы в конфиге. 
Вся эта фигня работает по файлу docs/docs.yaml, в котором описана схема возможных запросов к сервису в формате open-api 3.0 (другое название - swagger 3.0).

Интерактивный пример такой же фигни - https://petstore.swagger.io/

В этом интерфейсе можно делать запросы к сервису как по примерам забитым в схему, так и кастомные запросы с редактированием прямо в браузере.

Первый неочевидный момент - из-за разницы jsonrpc и openapi 3.0 каждый отдельный метод должен быть на уникальном адресе.
Чтобы обойти эту штуку - сделал кастомный роут, который принимает любое название в формате:

``адрес.сервиса/произвольный_метод``

Само название - не играет роли, в jsonrpc название метода передается внутри запроса.

Второй неочевидный момент - CORS.

В схеме можно задать адрес, на который будет уходить запрос из браузера. Но надо чтобы выбранный адрес совпадал с тем, что написан в строке браузера.
Классический пример - localhost и 0.0.0.0, в теории - одно и то же, на практике - все современные браузеры считают их разными в контексте CORS.